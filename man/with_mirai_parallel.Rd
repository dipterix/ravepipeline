% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/parallel-mirai.R
\name{with_mirai_parallel}
\alias{with_mirai_parallel}
\alias{lapply_jobs}
\title{Internal parallel functions}
\usage{
with_mirai_parallel(
  expr,
  workers = 0,
  globals = list(),
  serialization_config = list()
)

lapply_jobs(x, fun, ..., .globals = list(), callback = NULL)
}
\arguments{
\item{expr}{expression to evaluate with parallel workers}

\item{workers}{number of workers}

\item{globals, .globals}{global variables to be serialized}

\item{serialization_config}{serialization configurations}

\item{x}{a list, vector, array of R objects}

\item{fun}{function to apply to each elemnent of \code{x}}

\item{...}{additional arguments to be passed to \code{fun}}

\item{callback}{callback function, input is each element of \code{x} and
should return a string, for progress bar}
}
\description{
Experimental parallel functions, intended for internal use now. The goal
is to allow 'RAVE' functions to gain the potential benefit from parallel
computing, but allow users to control whether to do it.
}
\examples{



# Run without `with_mirai_parallel`
res <- lapply_jobs(1:5, function(x, ...) {
  c(child = Sys.getpid(), ...)
}, main = Sys.getpid())

simplify2array(res)

# When wrapped in `with_mirai_parallel`
with_mirai_parallel({
  res <- lapply_jobs(1:5, function(x, ...) {
    c(child = Sys.getpid(), ...)
  }, main = Sys.getpid())
  simplify2array(res)
}, workers = 1)

# Comparison
f <- function() {
  system.time({
    lapply_jobs(1:5, function(x, ...) {
      Sys.sleep(1)
      c(child = Sys.getpid(), ...)
    }, main = Sys.getpid())
  })
}

\dontrun{

# Without parallel
f()
#>    user  system elapsed
#>   0.022   0.019   5.010

# with parallel
with_mirai_parallel(f(), worker = 5)
#>    user  system elapsed
#>   0.002   0.001   1.146

}


}
